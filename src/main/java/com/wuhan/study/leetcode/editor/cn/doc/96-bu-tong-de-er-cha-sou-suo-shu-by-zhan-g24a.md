### 解题思路
[参考 代码随想录 的讲解](https://mp.weixin.qq.com/s/8VE8pDrGxTf8NEVYBDwONw)
状态转移方程：
n = 1个节点的二叉搜索树有1种；
![image.png](https://pic.leetcode-cn.com/1621576106-aOkIVZ-image.png)

n = 2个节点的二叉搜索树有2种；
![image.png](https://pic.leetcode-cn.com/1621576116-cNVeRb-image.png)

n = 3个节点的二叉搜索树有5种；
![image.png](https://pic.leetcode-cn.com/1621576156-qblPvv-image.png)

当1为头结点的时候，其右子树有两个节点，和n为2的时候两棵树的布局一样；
当3为头结点的时候，其左子树有两个节点，和n为2的时候两棵树的布局一样；
当2位头结点的时候，其左右子树都只有一个节点，和n为1的时候只有一棵树的布局一样的。
dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
有2个元素的搜索树数量就是dp[2]。
有1个元素的搜索树数量就是dp[1]。
有0个元素的搜索树数量就是dp[0]。
所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
![image.png](https://pic.leetcode-cn.com/1621576341-gIJWTh-image.png)
那么当有i个节点时，以j为头节点的数量为:
左子树的数量   *  右子树的数量
dp[j - 1]     *  ddp[i - i]
(0 ~ j - 1)个    (j + 1 ~ i)个

### 代码
```c
int numTrees(int n) {
    /* 1、dp数组含义：1到n组成的二叉搜索树数量 */
    int* dp = (int*)calloc(n + 1, sizeof(int));
    /* 3、dp初值：0个节点即为空树，也算二叉搜索树 */
    dp[0] = 1;
    /* 4、遍历顺序：从前向后，后面的dp根据前面的dp而来 */
    for (int i = 1; i <= n; i++) {
        /* 2、状态转移方程：dp[i]为i个节点组成的数量 */
        for (int j = 1; j <= i; j++) {
            /* 2、状态转移方程：dp[j-1]所有以j为头节点的左子树数量 
             * dp[i - j]所有以j为头节点的右子树数量 
             */
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
}
```